<CdrDoc Type='Filter' Id='CDR0000616048'>
<CdrDocCtl>
<DocValStatus readonly="yes">U</DocValStatus>
<DocActiveStatus readonly="yes">A</DocActiveStatus>
<DocTitle readonly="yes">Vendor Filter: GlossaryTermName</DocTitle>
<ReadyForReview readonly="yes">N</ReadyForReview>
</CdrDocCtl>
<CdrDocXml><![CDATA[<?xml      version = "1.0"?>
<!--
================================================================
$Id: CDR0000616048.xml,v 1.7 2008-10-03 21:06:04 venglisc Exp $

Filter to create Vendor XML for Glossary

$Log: not supported by cvs2svn $
================================================================ -->
<xsl:transform               xmlns:xsl = "http://www.w3.org/1999/XSL/Transform"
                             xmlns:cdr = "cips.nci.nih.gov/cdr"
               exclude-result-prefixes = "cdr"
                               version = "1.0">

 <xsl:include href = "cdr:name:Module: Vendor Filter Templates"/>
    
 <xsl:output                    method = "xml" 
                  omit-xml-declaration = "no"/>  

 <!-- Stylesheet level parameter DateFirstPub, passed in from the caller -->
 <xsl:param                       name = "DateFirstPub"
                                select = "''"/>

 <xsl:variable                    name = "whoAmI"
                                select = "'GlossaryTerm'"/>
 <!-- 
 =================================================================== 
 Copy DocId, TermName,TermDefinition, Term Pronunciation
 =================================================================== -->
 <xsl:template                   match = "GlossaryTermName">
  <xsl:text    disable-output-escaping = "yes">
&lt;!DOCTYPE GlossaryTerm &gt;</xsl:text>

  <xsl:variable                   name = "termName"
                                select = "normalize-space(TermName/
                                                          TermNameString)"/>
  <xsl:element                    name = "GlossaryTerm">
   <xsl:for-each                select = "document('cdrutil:/docid')">
    <xsl:attribute                name = "id">
     <xsl:value-of              select = "."/>
    </xsl:attribute>
   </xsl:for-each>
   <xsl:if                        test = "PdqKey">
    <xsl:attribute                name = "LegacyPDQID">
     <xsl:value-of              select = "PdqKey"/>
    </xsl:attribute>
   </xsl:if>

   <!--
   Test to make sure the TermName exists and hasn't been removed
   because it was within markup
   ============================================================= -->
   <xsl:if                        test = "$termName = ''">
    <xsl:message             terminate = "no">
     <xsl:text>&lt;LI&gt;&lt;b&gt;Error:&lt;/b&gt; TermName</xsl:text>
     <xsl:text> does not exist.&lt;BR/&gt;</xsl:text>
    </xsl:message> 
   </xsl:if>

   <xsl:apply-templates         select = "TermName"/>
   
   <xsl:for-each                select = "GlossaryTermConcept/
                                          TermDefinition">
    <TermDefinition>
     <xsl:apply-templates       select = "DefinitionText">
      <xsl:with-param             name = "language"
                                select = "'en'"/>
      <xsl:with-param             name = "audience"
                                select = "Audience"/>
     </xsl:apply-templates>
     <xsl:apply-templates       select = "Dictionary"
                                  mode = "copy"/>
     <xsl:apply-templates       select = "Audience"
                                  mode = "copy"/> 
    </TermDefinition>
   </xsl:for-each>

   <!--
   Make sure we only have either a shared MediaLink for both, English and
   Spanish or we have individual once but not both
   ====================================================================== -->
   <xsl:if                        test = "MediaLink
                                          and
                                          (TermDefinition/MediaLink
                                           or
                                           TranslatedTermDefinition/MediaLink)">
    <xsl:message              terminate = "no">
     <xsl:text>&lt;LI class="error" &gt;</xsl:text>
     <xsl:text>&lt;b&gt;Error:&lt;/b&gt; Invalid </xsl:text>
     <xsl:text>use of MediaLink.&lt;BR/&gt;</xsl:text>
    </xsl:message>
   </xsl:if>
   <xsl:apply-templates         select = "MediaLink |
                                          TermDefinition/
                                          MediaLink |
                                          TranslatedTermDefinition/
                                          MediaLink"/>

   <xsl:apply-templates         select = "TranslatedName"/>

   <xsl:for-each                select = "GlossaryTermConcept/
                                          TranslatedTermDefinition">
    <SpanishTermDefinition>
     <xsl:apply-templates       select = "DefinitionText">
      <xsl:with-param             name = "language"
                                select = "'es'"/>
      <xsl:with-param             name = "audience"
                                select = "Audience"/>
     </xsl:apply-templates>
     <xsl:apply-templates       select = "Dictionary"
                                  mode = "copy"/>
     <xsl:apply-templates       select = "Audience"
                                  mode = "copy"/> 
    </SpanishTermDefinition>
   </xsl:for-each>


   <!-- 
   ===================================================================
   Copy Date First Published and Date Last Modified
   =================================================================== -->
   <xsl:variable                  name = "CtrlBlk" 
                                select = "document('cdr:/*/CdrCtl')"/>
   <xsl:choose>
    <xsl:when                     test = "$CtrlBlk/CdrDocCtl/FirstPub/Date">
     <DateFirstPublished>
      <xsl:value-of             select = "substring-before ($CtrlBlk/
                                            CdrDocCtl/FirstPub/Date,'T')"/>
     </DateFirstPublished>
    </xsl:when>
    <xsl:otherwise>
     <xsl:call-template           name = "getDateFirstPub">
      <xsl:with-param             name = "date"
                                select = "$DateFirstPub"/>
     </xsl:call-template>    
    </xsl:otherwise>
   </xsl:choose>
   <xsl:apply-templates         select = "GlossaryTermConcept/
                                          TermDefinition[Audience = 'Patient']/
                                          DateLastModified" 
                                  mode = "copy"/>
  </xsl:element>
 </xsl:template>


 <!-- 
 =====================================================================
 The TermNameString is displayed as TermName in the vendor output
 ===================================================================== -->
 <xsl:template                   match = "TermName">
  <TermName>
   <xsl:value-of                select = "normalize-space(TermNameString)"/>
  </TermName>

  <xsl:apply-templates          select = "TermPronunciation"/>
 </xsl:template>


 <!-- 
 =====================================================================
 The TermNameString is displayed as TermName in the vendor output
 ===================================================================== -->
 <xsl:template                   match = "TranslatedName">
  <xsl:choose>
   <xsl:when                      test = "@language = 'es'">
    <SpanishTermName>
     <xsl:value-of              select = "normalize-space(TermNameString)"/>
    </SpanishTermName>
   </xsl:when>
   <xsl:otherwise>
    <UnknownTermName>
     <xsl:value-of              select = "normalize-space(TermNameString)"/>
    </UnknownTermName>
    </xsl:otherwise>
  </xsl:choose>
 </xsl:template>


 <!-- 
 =====================================================================
 The TermPronunciation needs to be displayed with parenthesis around 
 the name. 
 ===================================================================== -->
 <xsl:template                   match = "TermPronunciation">
  <xsl:element                    name = "{name()}">
   <xsl:text>(</xsl:text>
    <xsl:value-of               select = "normalize-space(.)"/>
   <xsl:text>)</xsl:text>
  </xsl:element>
 </xsl:template>


 <!-- 
 =====================================================================
 The TermDefinition and SpanishTermDefinition can contain inline 
 markup and needs to be handled with a template
 ===================================================================== -->
 <xsl:template                   match = "DefinitionText">
  <xsl:param                      name = "language"/>
  <xsl:param                      name = "audience"/>

  <xsl:element                    name = "{name()}">
   <xsl:apply-templates           mode = "copy">
    <xsl:with-param               name = "language"
                                select = "$language"/>
    <xsl:with-param               name = "audience"
                                select = "$audience"/>
   </xsl:apply-templates>

   <!-- 
   Need to add the Also-called elements at the end of the DefinitionText
   ===================================================================== -->
   <xsl:variable                  name = "gtnId"
                                select = "document('cdrutil:/docid')"/>
   <xsl:variable                  name = "gtnNormId"
                                select = "number(
                                           substring-before(
                                           concat(
                                           substring-after($gtnId, 'CDR'),
                                                               '#'), '#'))"/>
   <xsl:variable                  name = "sqlGTCQuery">
          SELECT int_val
            FROM query_term
           WHERE path = '/GlossaryTermName/GlossaryTermConcept/@cdr:ref'
             AND doc_id = ?
   </xsl:variable>

   <xsl:variable                  name = "sqlGTCRows" 
                                  select = "document(
                                           concat('cdrutil:/sql-query/',
                                                   $sqlGTCQuery,
                                                   '~',
                                                   $gtnNormId))"/>

   <xsl:variable                  name = "sqlGTCId">
    <xsl:value-of               select = "$sqlGTCRows/SqlResult/row/col"/>
   </xsl:variable>

   <xsl:variable                  name = "sqlGTNQuery">
          SELECT n.value
            FROM query_term gtc
            join query_term n
              on n.doc_id = gtc.doc_id
             and n.path = '/GlossaryTermName/' + ? + '/TermNameString'
            join document d
              on d.id = n.doc_id
           WHERE gtc.path = '/GlossaryTermName/GlossaryTermConcept/@cdr:ref'
             AND gtc.int_val = ?
             AND d.active_status = 'A'
             AND n.doc_id != ?
           order by n.value
   </xsl:variable>

   <!--
   We need two different queries depending on the language attribute
   ================================================================= -->
   <xsl:variable                  name = "queryRows">
    <xsl:choose>
     <xsl:when                     test = "$language = 'en'">
      <xsl:copy-of               select = "document(
                                           concat('cdrutil:/sql-query/',
                                                   $sqlGTNQuery,
                                                   '~TermName~',
                                                   $sqlGTCId,
                                                   '~',
                                                   $gtnNormId))"/>
     </xsl:when>
     <xsl:when                    test = "$language = 'es'">
      <xsl:copy-of              select = "document(
                                           concat('cdrutil:/sql-query/',
                                                   $sqlGTNQuery,
                                                   '~TranslatedName~',
                                                   $sqlGTCId,
                                                   '~',
                                                   $gtnNormId))"/>
     </xsl:when>
    </xsl:choose>
   </xsl:variable>

   <!--
   Also-called is only added if the SQL query returns with a record
   ================================================================ -->
   <xsl:if                        test = "$queryRows/SqlResult/row">
    <xsl:choose>
     <!--
     A) Only one Also-called exists
     ============================== -->
     <xsl:when                    test = "count($queryRows/SqlResult/row) = 1">
      <xsl:choose>
       <xsl:when                  test = "$language = 'en'">
        <xsl:text> Also called </xsl:text>
       </xsl:when>
       <xsl:when                  test = "$language = 'es'">
        <xsl:text> Tambi&#xE9;n se llama </xsl:text>
       </xsl:when>
      </xsl:choose>
      <xsl:value-of             select = "$queryRows
                                             /SqlResult
                                             /row
                                             /col[@name='value']"/>
      <xsl:text>. </xsl:text>
     </xsl:when>
     <!--
     B) Exactly two Also-calleds exist
     ================================= -->
     <xsl:when                    test = "count($queryRows/SqlResult/row) = 2">
      <xsl:choose>
       <xsl:when                  test = "$language = 'en'">
        <xsl:text> Also called </xsl:text>
       </xsl:when>
       <xsl:when                  test = "$language = 'es'">
        <xsl:text> Tambi&#xE9;n se llama </xsl:text>
       </xsl:when>
      </xsl:choose>
      <xsl:value-of             select = "$queryRows
                                             /SqlResult
                                             /row[@id = 1]
                                             /col[@name='value']"/>
      <xsl:choose>
       <xsl:when                  test = "$language = 'en'">
        <xsl:text> and </xsl:text>
       </xsl:when>
       <xsl:when                  test = "$language = 'es'">
        <xsl:text> y </xsl:text>
       </xsl:when>
      </xsl:choose>
      <xsl:value-of             select = "$queryRows
                                             /SqlResult
                                             /row[@id = 2]
                                             /col[@name='value']"/>
      <xsl:text>. </xsl:text>
     </xsl:when>
     <!--
     C) More than two Also-called exist
     ================================== -->
     <xsl:otherwise>
      <xsl:choose>
       <xsl:when                  test = "$language = 'en'">
        <xsl:text> Also called </xsl:text>
       </xsl:when>
       <xsl:when                  test = "$language = 'es'">
        <xsl:text> Tambi&#xE9;n se llama </xsl:text>
       </xsl:when>
      </xsl:choose>
      <xsl:for-each             select = "$queryRows/SqlResult/row">
       <xsl:if                    test = "position() = last()">
        <xsl:choose>
         <xsl:when                test = "$language = 'en'">
          <xsl:text> and </xsl:text>
         </xsl:when>
         <xsl:when                test = "$language = 'es'">
          <xsl:text> y </xsl:text>
         </xsl:when>
        </xsl:choose>
       </xsl:if>

       <xsl:value-of            select = "col[@name='value']"/>

       <xsl:choose>
        <xsl:when                 test = "position() = last()">
         <xsl:text>. </xsl:text>
        </xsl:when>
        <xsl:otherwise>
         <xsl:text>, </xsl:text>
        </xsl:otherwise>
       </xsl:choose>
      </xsl:for-each>
     </xsl:otherwise>
    </xsl:choose>
   </xsl:if>

  </xsl:element>
 </xsl:template>


 <!--
 =====================================================================
 Replacing the place holders within the definition text with the 
 appropriate text definitions.
 ===================================================================== -->
 <xsl:template                   match = "PlaceHolder"
                                  mode = "copy">
  <xsl:param                      name = "language"
                                select = "'en'"/>
  <xsl:param                      name = "audience"
                                select = "'Patient'"/>

  <xsl:variable                   name = "ph"
                                select = "@name"/>
  <xsl:variable                   name = "termName">
   <xsl:choose>
    <xsl:when                     test = "$language = 'en'">
     <xsl:value-of              select = "//TermName/
                                            TermNameString"/>
    </xsl:when>
    <xsl:when                     test = "$language = 'es'">
     <xsl:value-of              select = "//TranslatedName[@language = 'es']/
                                            TermNameString"/>
    </xsl:when>
    <xsl:otherwise>
     <xsl:text>TBD</xsl:text>
    </xsl:otherwise>
   </xsl:choose>
  </xsl:variable>

  <xsl:choose>
   <!-- 
   A) The canned name TERMNAME has been specified as a place holder
      We replace the term name with the correct term for this language
   ==================================================================== -->
   <xsl:when                      test = "$ph = 'TERMNAME'">
    <xsl:value-of               select = "$termName"/>
   </xsl:when>
   <!--
   B) The canned name CAPPEDTERMNAME has been entered as a place holder
      We replace the term name and capitalize it unless the 
      PreservCase attribute of the TermNameString has been specified
   ==================================================================== -->
   <xsl:when                      test = "$ph = 'CAPPEDTERMNAME'">
    <xsl:choose>
     <!-- Preserve the case of the term name -->
     <xsl:when                    test = "//TermName[@language = $language]/
                                             TermNameString/
                                             @PreserveCase = 'Yes'">


      <xsl:value-of             select = "normalize-space($termName)"/>
     </xsl:when>
     <!-- Cap the term name -->
     <xsl:otherwise>
      <xsl:call-template          name = "convertCase">
       <xsl:with-param            name = "convString"
                                select = "substring(
                                           normalize-space($termName), 1, 1)"/>
       <xsl:with-param            name = "convertTo"
                                select = "'proper'"/>
      </xsl:call-template>
      <xsl:value-of             select = "substring(
                                           normalize-space($termName), 2)"/>
     </xsl:otherwise>
    </xsl:choose>
   </xsl:when>
   <!--
   C) Replace the PlaceHolder attribute string with the proper 
      ReplacementText element
   ==================================================================== -->
   <xsl:otherwise>
    <!-- 
    In case the same PlaceHolder string is used in the English as well
    as Spanish section we need to ensure to pick up the right replacement
    text for the correct language.
    ===================================================================== -->
    <xsl:choose>
     <xsl:when                    test = "$language = 'en'">
      <xsl:choose>
       <xsl:when                  test = "//GlossaryTermConcept
                                           /TermDefinition[Audience = $audience]
                                           /ReplacementText[@name = $ph]">
        <xsl:value-of           select = "//GlossaryTermConcept
                                           /TermDefinition[Audience = $audience]
                                           /ReplacementText[@name = $ph]"/>
       </xsl:when>
       <xsl:otherwise>
        <xsl:value-of           select = "normalize-space(
                                           /GlossaryTermName
                                           /ReplacementText[@name = $ph])"/>
       </xsl:otherwise>
      </xsl:choose>
     </xsl:when>
     <xsl:when                    test = "$language = 'es'">
      <xsl:choose>
       <xsl:when                  test = "//GlossaryTermConcept
                                           /TranslatedTermDefinition[Audience = $audience]
                                           /ReplacementText[@name = $ph]">
        <xsl:value-of           select = "//GlossaryTermConcept
                                           /TranslatedTermDefinition[Audience = $audience]
                                           /ReplacementText[@name = $ph]"/>
       </xsl:when>
       <xsl:otherwise>
        <xsl:value-of           select = "normalize-space(
                                           /GlossaryTermName
                                           /ReplacementText[@name = $ph])"/>
       </xsl:otherwise>
      </xsl:choose>
     </xsl:when>
    </xsl:choose>
   </xsl:otherwise>
  </xsl:choose>
<!--
      <xsl:value-of             select = "normalize-space(
                                           //TranslatedTermDefinition/
                                             ReplacementText[@name = $ph])"/>
-->
 </xsl:template>


 <!-- 
 ===================================================================
 Template for extracting SummaryRef Definition
 =================================================================== -->
 <xsl:template                   match = "SummaryRef"
                                  mode = "copy">
  <xsl:variable                   name = "hrefId"
                                select = "@cdr:href"/>
  <xsl:variable                   name = "hrefNormId"
                                select = "number(
                                           substring-before(
                                           concat(
                                           substring-after(@cdr:href, 'CDR'),
                                                               '#'), '#'))"/>
    <!--
    Extracting the content of the SummaryURL attribute to be used for 
    populating the url attribute of the SummaryRef element.  This 
    information has to be retrieved via a SQL query from the database
    ================================================================= -->
    <xsl:variable                 name = "sqlQuery">
     SELECT path, value 
       FROM query_term_pub 
      WHERE doc_id = ?
        AND path = '/Summary/SummaryMetaData/SummaryURL/@cdr:xref'
    </xsl:variable>

    <!-- 
    Note: Don't perform a normalize-space here since it would convert
          the resulting node into a string
    ================================================================== -->
    <xsl:variable                 name = "queryRows"
                                select = "document(
                                           concat('cdrutil:/sql-query/',
                                                   $sqlQuery,
                                                   '~',
                                                   $hrefNormId))"/>
    <!--
    Note:  The url created by function getSummaryURL has no trailing 
           slash ('/'), specifies the domain as http://cancer.gov and
           is normalized
    ================================================================= -->
    <xsl:variable                 name = "url">
     <xsl:call-template           name = "getSummaryURL">
      <xsl:with-param             name = "url"
                                select = "normalize-space(
                                            $queryRows
                                            /SqlResult
                                            /row

                                            /col[@name='value'])"/>

     </xsl:call-template>
    </xsl:variable>
  
    <!--
    The SummaryRef url attribute is populated from the xref attribute of
    the SummaryURL element displaying the full path without the domain
    ===================================================================== -->
  <SummaryRef>
   <xsl:attribute                 name = "href">
    <xsl:value-of               select = "$hrefId"/>
   </xsl:attribute>
   <xsl:attribute                 name = "url">
    <xsl:choose>
     <xsl:when                    test = "starts-with($url, 'http')">
      <xsl:value-of             select = "substring-after($url, '.gov')"/>
     </xsl:when>

     <xsl:otherwise>
      <xsl:value-of             select = "$url"/>
     </xsl:otherwise>
    </xsl:choose>
   </xsl:attribute>
   <xsl:apply-templates/>
  </SummaryRef>
 </xsl:template>


 <!-- 
 ==============================================================
 Template for extracting External Ref Definition
 ============================================================== -->
 <xsl:template                   match = "ExternalRef">
  <ExternalRef>
   <xsl:attribute                 name = "xref">
    <xsl:value-of               select = "@cdr:xref"/>
   </xsl:attribute>
   <xsl:apply-templates/>
  </ExternalRef>
 </xsl:template>
</xsl:transform>
]]>
</CdrDocXml>
</CdrDoc>