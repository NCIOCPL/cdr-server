<?xml version = "1.0" encoding="utf-8"?>
<!-- Filter title: Vendor Filter: GlossaryTermName -->
<!--
====================================================================

Filter to create Vendor XML for Glossary

BZIssue::4973 - [Glossary] Modification to Publication Filters
BZIssue::4995 - [Glossary] Non Publishable Also Calls in the dictionary
OCECDR-3528: Ability to put links to other Dictionary terms in More
             Information block on Cancer.gov
OCECDR-3966: Add URL Attribute for Gatekeeper Processing

==================================================================== -->
<xsl:transform               xmlns:xsl = "http://www.w3.org/1999/XSL/Transform"
                               version = "1.0"
               exclude-result-prefixes = "cdr"
                             xmlns:cdr = "cips.nci.nih.gov/cdr">

 <xsl:output                    method = "xml"
                  omit-xml-declaration = "no"/>

 <xsl:include  href = "cdr:name:Module: Vendor Filter Templates"/>

 <!-- Stylesheet level parameter DateFirstPub, passed in from the caller -->
 <xsl:param                       name = "DateFirstPub"
                                select = "''"/>

 <xsl:variable                    name = "whoAmI"
                                select = "'GlossaryTerm'"/>
 <!--
 ===================================================================
 Copy DocId, TermName,TermDefinition, Term Pronunciation
 =================================================================== -->
 <xsl:template                   match = "GlossaryTermName">
  <xsl:text    disable-output-escaping = "yes">
&lt;!DOCTYPE GlossaryTerm &gt;</xsl:text>

  <xsl:variable                   name = "termName"
                                select = "normalize-space(TermName/
                                                          TermNameString)"/>
  <xsl:element                    name = "GlossaryTerm">
   <xsl:for-each                select = "document('cdrutil:/docid')">
    <xsl:attribute                name = "id">
     <xsl:value-of              select = "."/>
    </xsl:attribute>
   </xsl:for-each>
   <xsl:if                        test = "PdqKey">
    <xsl:attribute                name = "LegacyPDQID">
     <xsl:value-of              select = "PdqKey"/>
    </xsl:attribute>
   </xsl:if>

   <!--
   Test to make sure the TermName exists and hasn't been removed
   because it was within markup
   ============================================================= -->
   <xsl:if                        test = "$termName = ''">
    <xsl:message             terminate = "yes">
     <xsl:text>Missing term name.</xsl:text>
    </xsl:message>
   </xsl:if>

   <xsl:apply-templates         select = "TermName"/>

   <xsl:for-each                select = "GlossaryTermConcept/
                                          TermDefinition[DefinitionStatus =
                                                             'Approved'
                                                         or
                                                         DefinitionStatus =
                                                           'Revision pending']">
    <TermDefinition>
     <xsl:apply-templates       select = "DefinitionText">
      <xsl:with-param             name = "language"
                                select = "'en'"/>
      <xsl:with-param             name = "audience"
                                select = "Audience"/>
     </xsl:apply-templates>
     <xsl:apply-templates       select = "Dictionary"
                                  mode = "copy"/>
     <xsl:apply-templates       select = "Audience"
                                  mode = "copy"/>
    </TermDefinition>
   </xsl:for-each>

   <!--
   We're grouping all Media files together, first come the audio files
   then come the images.
   =================================================================== -->
   <xsl:apply-templates         select = "TermName/
                                            MediaLink">
    <xsl:with-param               name = "audioLanguage"
                                select = "'en'"/>
   </xsl:apply-templates>
   <xsl:apply-templates         select = "TranslatedName/
                                            MediaLink">
    <xsl:with-param               name = "audioLanguage"
                                select = "'es'"/>
   </xsl:apply-templates>

   <!--
   Next come the image files.
   Make sure we only have either a shared MediaLink for both, English and
   Spanish or we have individual MediaLinks but not both
   ====================================================================== -->
   <xsl:for-each                select = "GlossaryTermConcept">
    <xsl:variable                 name = "ev1"
                                select = "MediaLink/
                                            MediaID/@cdr:ref"/>

    <xsl:for-each               select = "TermDefinition/
                                            MediaLink/
                                            MediaID">

     <xsl:if                      test = "$ev1 = @cdr:ref">
      <xsl:message           terminate = "no">
       <xsl:text>Invalid use of MediaLink.</xsl:text>
      </xsl:message>
     </xsl:if>

    </xsl:for-each>
   </xsl:for-each>

   <xsl:apply-templates         select = "GlossaryTermConcept/
                                            MediaLink            |
                                          GlossaryTermConcept/
                                            TermDefinition/
                                            MediaLink            |
                                          GlossaryTermConcept/
                                            TranslatedTermDefinition/
                                            MediaLink"/>



   <!--
   Last come the video elements
   Firstly, ensure a single video is not used in the definition section
   *and* in the shared section but don't fail the document
   ====================================================================== -->
   <xsl:for-each                select = "GlossaryTermConcept">
    <xsl:variable                 name = "ev1"
                                select = "EmbeddedVideo/
                                            MediaID/@cdr:ref"/>

    <xsl:for-each               select = "TermDefinition/
                                            EmbeddedVideo/
                                            MediaID">

     <xsl:if                      test = "$ev1 = @cdr:ref">
      <xsl:message           terminate = "no">
       <xsl:text>Invalid use of EmbeddedVideo.</xsl:text>
      </xsl:message>
     </xsl:if>

    </xsl:for-each>
   </xsl:for-each>

   <xsl:apply-templates         select = "GlossaryTermConcept/
                                            EmbeddedVideo        |
                                          GlossaryTermConcept/
                                            TermDefinition/
                                            EmbeddedVideo        |
                                          GlossaryTermConcept/
                                            TranslatedTermDefinition/
                                            EmbeddedVideo"/>
   <!--
   If a translated name exists, process it.  If a translated name does
   not exist, it's because a translation for the word does not exist
   in the translated language and we're using the English word with
   the note "en englais".
   However, we only want to do this if a translated concept definition
   exists for this term.
   =================================================================== -->
   <!--
   If the TranslatedStatus is not 'Approved' or 'Revision pending'
   don't display the Spanish definition.
   =================================================================== -->
   <xsl:if                        test = "GlossaryTermConcept/
                                            TranslatedTermDefinition/
                                            TranslatedStatus = 'Approved'
                                          or
                                          GlossaryTermConcept/
                                            TranslatedTermDefinition/
                                            TranslatedStatus = 'Revision pending'">
    <xsl:choose>
     <xsl:when                    test = "TranslatedName">
      <xsl:apply-templates      select = "TranslatedName"/>
     </xsl:when>
     <xsl:otherwise>
      <xsl:if                     test = "GlossaryTermConcept/
                                           TranslatedTermDefinition">
       <SpanishTermName>
        <xsl:value-of           select = "normalize-space(TermName/
                                                            TermNameString)"/>
        <xsl:text> (en ingl&#xE9;s)</xsl:text>
       </SpanishTermName>
      </xsl:if>
     </xsl:otherwise>
    </xsl:choose>

    <!--
    Process the translated definition for the language
    ================================================== -->
    <xsl:for-each               select = "GlossaryTermConcept/
                                           TranslatedTermDefinition">
     <SpanishTermDefinition>
      <xsl:apply-templates      select = "DefinitionText">
       <xsl:with-param            name = "language"
                                select = "'es'"/>
       <xsl:with-param            name = "audience"
                                select = "Audience"/>
      </xsl:apply-templates>
      <xsl:apply-templates      select = "Dictionary"
                                  mode = "copy"/>
      <xsl:apply-templates      select = "Audience"
                                  mode = "copy"/>
     </SpanishTermDefinition>
    </xsl:for-each>
   </xsl:if>


   <!--
   ===================================================================
   Copy Date First Published and Date Last Modified
   =================================================================== -->
   <xsl:variable                  name = "CtrlBlk"
                                select = "document('cdr:/*/CdrCtl')"/>
   <xsl:variable                  name = "dateTime"
                                select = "$CtrlBlk/CdrDocCtl/FirstPub/Date"/>
   <xsl:variable                  name = "date">
    <xsl:choose>
     <xsl:when                    test = "contains($dateTime, 'T')">
      <xsl:value-of             select = "substring-before($dateTime, 'T')"/>
     </xsl:when>
     <xsl:otherwise>
      <xsl:value-of             select = "$dateTime"/>
     </xsl:otherwise>
    </xsl:choose>
   </xsl:variable>
   <xsl:choose>
    <xsl:when                     test = "not($date)">
     <DateFirstPublished>
      <xsl:value-of             select = "$date"/>
     </DateFirstPublished>
    </xsl:when>
    <xsl:otherwise>
     <xsl:call-template           name = "getDateFirstPub">
      <xsl:with-param             name = "date"
                                select = "$DateFirstPub"/>
     </xsl:call-template>
    </xsl:otherwise>
   </xsl:choose>
   <xsl:apply-templates         select = "GlossaryTermConcept/
                                          TermDefinition[Audience = 'Patient']/
                                          DateLastModified"
                                  mode = "copy"/>
  <xsl:apply-templates          select = "GlossaryTermConcept/
                                            RelatedInformation"/>

  <!-- select = "GlossaryTermConcept/
                                            RelatedExternalRef  |
                                          GlossaryTermConcept/
                                            RelatedSummaryRef   |
                                          GlossaryTermConcept/
                                            RelatedDrugSummaryRef"/ -->
  </xsl:element>
 </xsl:template>


 <!--
 =====================================================================
 Template to create the RelatedInformation wrapper element
 ===================================================================== -->
 <xsl:template                   match = "RelatedInformation">
  <xsl:copy>
   <xsl:apply-templates         select = "RelatedSummaryRef      |
                                          RelatedDrugSummaryLink |
                                          RelatedExternalRef     |
                                          RelatedGlossaryTermNameLink"/>
  </xsl:copy>
 </xsl:template>


 <!--
 =====================================================================
 Template to create the RelatedSummaryRef element
 ===================================================================== -->
 <xsl:template                   match = "RelatedSummaryRef">
   <xsl:element                   name = "{name()}">
    <xsl:if                       test = "@UseWith">
     <xsl:attribute               name = "UseWith">
      <xsl:value-of             select = "@UseWith"/>
     </xsl:attribute>
    </xsl:if>

    <xsl:attribute                name = "href">
     <xsl:value-of              select = "@cdr:ref"/>
    </xsl:attribute>

    <xsl:attribute                name = "url">
     <xsl:value-of              select = "substring-after(
                                           Summary/
                                           SummaryMetaData/
                                           SummaryURL/@cdr:xref,'cancer.gov')"/>
    </xsl:attribute>
    <xsl:apply-templates        select = "Summary/SummaryTitle"/>
  </xsl:element>
 </xsl:template>


 <!--
 =====================================================================
 Template to create the RelatedDrugSummaryRef element
 Adding UseWith="en" attribute to prevent RelatedInformation link to
 an English DrugSummary in the Spanish section
 ===================================================================== -->
 <xsl:template                   match = "RelatedDrugSummaryLink">
   <xsl:element                   name = "RelatedDrugSummaryRef">
    <xsl:choose>
     <xsl:when                    test = "@UseWith">
      <xsl:attribute              name = "UseWith">
       <xsl:value-of            select = "@UseWith"/>
      </xsl:attribute>
     </xsl:when>
     <xsl:otherwise>
      <xsl:attribute              name = "UseWith">
       <xsl:text>en</xsl:text>
      </xsl:attribute>
     </xsl:otherwise>
    </xsl:choose>
    <xsl:attribute                name = "href">
     <xsl:value-of              select = "@cdr:ref"/>
    </xsl:attribute>

    <xsl:attribute                name = "url">
     <xsl:value-of              select = "substring-after(
                                           DrugInformationSummary/
                                           DrugInfoMetaData/
                                           URL/@cdr:xref, 'cancer.gov')"/>
    </xsl:attribute>

    <xsl:apply-templates        select = "DrugInformationSummary/Title"/>
  </xsl:element>
 </xsl:template>


 <!--
 =====================================================================
 Template to create the RelatedExternalRef element
 ===================================================================== -->
 <xsl:template                   match = "RelatedExternalRef">
  <xsl:copy-of                  select = "."/>
 </xsl:template>


 <!--
 =====================================================================
 Template to create the RelatedTGlossaryTermRef element
 The users are entering a single term name.  The filter will then
 translate this based on the language and audience available. The
 element is being duplicated displaying one entry for each
 GlossaryConcept definition but only if the related term exists for
 the specified dictionary and language as well.
 Example:
    Glossary Term pedigree exists with definition
      - HP dictionary
      - Patient dictionary
      - Spanish patient dictionary
    Related Glossary Term "gene" (not real data)
      This term contains 3 definitions resulting
      in 3 RelatedGlossaryTermRefs
    Related Glossary Term "breastbone) (not real data)
      This term contains 2 definitions resulting
      in 2 RelatedGlossaryTermRefs
 ===================================================================== -->
 <xsl:template                   match = "RelatedGlossaryTermNameLink">
  <xsl:variable                   name = "relRef"
                                select = "@cdr:ref"/>

   <!--
   Scan through all existing definitions of the glossary.  Each
   definition will potentially create one related glossary link
   ============================================================= -->
   <xsl:for-each                select = "/GlossaryTermName/
                                            GlossaryTermConcept/
                                            TermDefinition[Audience] |
                                          /GlossaryTermName/
                                            GlossaryTermConcept/
                                            TranslatedTermDefinition[Audience]">

    <!--
    Scan through each concept of the related glossary term and only
    display a related glossary link element if both, the language
    and the audience match
    Note:  'thisLanguage' is *not* the en/es value but
           TermDefinition/TranslatedTermDefinition
    =============================================================== -->
    <xsl:variable                 name = "thisAudience"
                                select = "Audience"/>
    <xsl:variable                 name = "thisLanguage"
                                select = "name()"/>
    <xsl:for-each               select = "/GlossaryTermName/
                                            GlossaryTermConcept/
                                            RelatedInformation/
                                            RelatedGlossaryTermNameLink
                                              [@cdr:ref = $relRef]/
                                            GlossaryTermName">
     <xsl:for-each              select = "GlossaryTermConcept/
                                            TermDefinition |
                                          GlossaryTermConcept/
                                            TranslatedTermDefinition">
      <!--
      Throw out non-matching glossary links
      ============================================================== -->
      <xsl:if                     test = "Audience = $thisAudience
                                          and
                                          name() = $thisLanguage">

       <xsl:element               name = "RelatedGlossaryTermRef">
        <xsl:attribute            name = "href">
         <xsl:value-of          select = "$relRef"/>
        </xsl:attribute>

        <!--
        If no language has been specified the language default 'en' is used
        =================================================================== -->
        <xsl:attribute            name = "UseWith">
         <xsl:choose>
          <xsl:when               test = "@language">
           <xsl:value-of        select = "@language"/>
          </xsl:when>
          <xsl:otherwise>
           <xsl:text>en</xsl:text>
          </xsl:otherwise>
         </xsl:choose>
        </xsl:attribute>

        <!--
        Rename the attributes to match the values in the DTD
        ==================================================== -->
        <xsl:attribute            name = "audience">
         <xsl:choose>
          <xsl:when               test = "Audience = 'Patient'">
           <xsl:text>Patients</xsl:text>
          </xsl:when>
          <xsl:otherwise>
           <xsl:text>Health_professionals</xsl:text>
          </xsl:otherwise>
         </xsl:choose>
        </xsl:attribute>

        <xsl:call-template        name = "getRelatedGlossaryName">
         <xsl:with-param          name = "relRef"
                                select = "$relRef"/>
         <xsl:with-param          name = "thisLanguage"
                                select = "$thisLanguage"/>
        </xsl:call-template>
       </xsl:element>
      </xsl:if>
     </xsl:for-each>
    </xsl:for-each>
   </xsl:for-each>

 </xsl:template>


 <!--
 =====================================================================
 Template to pick up the glossary term name for the related terms
 ===================================================================== -->
 <xsl:template                    name = "getRelatedGlossaryName">
  <xsl:param                      name = "relRef"
                                select = "'0'"/>
  <xsl:param                      name = "thisLanguage"
                                select = "''"/>
  <!--
  The parameter 'thisLanguage' is not the en/es value but indicates
  the language by the element name (TermDefinition/TranslatedTermDefinition)
  Converting it here to make it less confusing.
  ========================================================================== -->
  <xsl:variable                   name = "language">
   <xsl:choose>
    <xsl:when                     test = "$thisLanguage = 'TermDefinition'">
     <xsl:text>en</xsl:text>
    </xsl:when>
    <xsl:otherwise>
     <xsl:text>es</xsl:text>
    </xsl:otherwise>
   </xsl:choose>
  </xsl:variable>

  <xsl:choose>
   <xsl:when                      test = "$language = 'en'">
    <xsl:apply-templates        select = "/GlossaryTermName/
                                            GlossaryTermConcept/
                                            RelatedInformation/
                                            RelatedGlossaryTermNameLink
                                              [@cdr:ref = $relRef]/
                                            GlossaryTermName/
                                            TermName/
                                            TermNameString"/>
   </xsl:when>
   <xsl:otherwise>
    <xsl:apply-templates        select = "/GlossaryTermName/
                                            GlossaryTermConcept/
                                            RelatedInformation/
                                            RelatedGlossaryTermNameLink
                                              [@cdr:ref = $relRef]/
                                            GlossaryTermName/
                                            TranslatedName/
                                            TermNameString"/>
   </xsl:otherwise>
  </xsl:choose>
 </xsl:template>


 <!--
 =====================================================================
 The TermNameString is displayed as TermName in the vendor output
 ===================================================================== -->
 <xsl:template                   match = "TermName">
  <TermName>
   <xsl:value-of                select = "normalize-space(TermNameString)"/>
  </TermName>

  <xsl:apply-templates          select = "TermPronunciation"/>
 </xsl:template>


 <!--
 =====================================================================
 The TermNameString is displayed as TermName in the vendor output
 ===================================================================== -->
 <xsl:template                   match = "TranslatedName">
  <xsl:choose>
   <xsl:when                      test = "@language = 'es'
                                          and
                                          not(@NameType)">
    <SpanishTermName>
     <xsl:value-of              select = "normalize-space(TermNameString)"/>
    </SpanishTermName>

   </xsl:when>
   <xsl:when                      test = "@language = 'es'
                                          and
                                          @NameType">
    <!-- Ignore "alternate" translated names -->
   </xsl:when>
   <xsl:otherwise>
    <UnknownLanguage>
     <xsl:value-of              select = "normalize-space(TermNameString)"/>
    </UnknownLanguage>
   </xsl:otherwise>
  </xsl:choose>
 </xsl:template>


 <!--
 =====================================================================
 The TermPronunciation needs to be displayed with parenthesis around
 the name.
 ===================================================================== -->
 <xsl:template                   match = "TermPronunciation">
  <xsl:element                    name = "{name()}">
   <xsl:text>(</xsl:text>
    <xsl:value-of               select = "normalize-space(.)"/>
   <xsl:text>)</xsl:text>
  </xsl:element>
 </xsl:template>



 <!--
 =====================================================================
 The TermDefinition and SpanishTermDefinition can contain inline
 markup and needs to be handled with a template
 ===================================================================== -->
 <xsl:template                   match = "DefinitionText">
  <xsl:param                      name = "language"/>
  <xsl:param                      name = "audience"/>

  <xsl:element                    name = "{name()}">
   <xsl:apply-templates           mode = "copy">
    <xsl:with-param               name = "language"
                                select = "$language"/>
    <xsl:with-param               name = "audience"
                                select = "$audience"/>
   </xsl:apply-templates>

   <!--
   Need to add the Also-called elements at the end of the DefinitionText
   ===================================================================== -->
   <xsl:variable                  name = "gtnId"
                                select = "document('cdrutil:/docid')"/>
   <xsl:variable                  name = "gtnNormId"
                                select = "number(
                                           substring-before(
                                           concat(
                                           substring-after($gtnId, 'CDR'),
                                                               '#'), '#'))"/>
   <xsl:variable                  name = "sqlGTCQuery">
          SELECT int_val
            FROM query_term
           WHERE path = '/GlossaryTermName/GlossaryTermConcept/@cdr:ref'
             AND doc_id = ?
   </xsl:variable>

   <xsl:variable                  name = "sqlGTCRows"
                                  select = "document(cdr:escape-uri(
                                           concat('cdrutil:/sql-query/',
                                                   $sqlGTCQuery,
                                                   '~',
                                                   $gtnNormId)))"/>

   <xsl:variable                  name = "sqlGTCId">
    <xsl:value-of               select = "$sqlGTCRows/SqlResult/row/col"/>
   </xsl:variable>

   <!--
        The queries for EN and ES are almost identical except for the
        NOT IN clause, but I'm unable to substitute an entire statement
        with a variable (see the join using node_loc)
   -->
   <xsl:variable                  name = "sqlGTNQuery">
    <xsl:choose>
     <xsl:when                    test = "$language = 'en'">
          SELECT n.value
            FROM query_term gtc
            JOIN query_term n
              ON n.doc_id = gtc.doc_id
             AND n.path = '/GlossaryTermName/TermName/TermNameString'
            JOIN document d
              ON d.id = n.doc_id
            JOIN query_term gts
              ON d.id = gts.doc_id
             AND gts.path = '/GlossaryTermName/TermNameStatus'
             -- AND LEFT(n.node_loc, 4) = LEFT(gts.node_loc, 4)  -- ES only
    left outer join query_term t
              on t.doc_id = n.doc_id
             AND t.path = '/GlossaryTermName/TermName/@NameType'
             -- AND LEFT(n.node_loc, 4) = LEFT(t.node_loc, 4)  -- ES only
           WHERE gtc.path = '/GlossaryTermName/GlossaryTermConcept/@cdr:ref'
             AND gtc.int_val = ?
             AND d.active_status = 'A'
             AND gts.value in ('Approved', 'Revision pending')
              -- Don't include the glossary term itself in the also-called list
              -- Making use of the fact that alternate names only exist for
              -- Spanish terms, therefore an outer join will display NULL values
              -- for records without alternate names
             AND n.value not in (
                 SELECT q.value
                   FROM query_term q
        LEFT OUTER JOIN query_term a
                     ON a.doc_id = q.doc_id
                    AND a.path = '/GlossaryTermName/TermName/@NameType'
                    AND left(a.node_loc, 4) = left(q.node_loc, 4)
                  WHERE q.doc_id = ?
                    AND q.path = '/GlossaryTermName/TermName/TermNameString'
                    AND a.doc_id is null
                    )
             -- Don't include the alternate names unless they are alternates of the term itself
             -- This "not in" is only relevant for the Spanish selection
             AND n.value not in (
                 SELECT q.value
                   FROM query_term q
        LEFT OUTER JOIN query_term a
                     ON a.doc_id = q.doc_id
                    AND a.path = '/GlossaryTermName/TermName/@NameType'
                    AND left(a.node_loc, 4) = left(q.node_loc, 4)
                  WHERE q.doc_id != ?
                    AND q.path = '/GlossaryTermName/TermName/TermNameString'
                    AND a.doc_id is NOT null
                    )
           ORDER BY n.value
     </xsl:when>
     <xsl:when                    test = "$language = 'es'">
          SELECT n.value
            FROM query_term gtc
            JOIN query_term n
              ON n.doc_id = gtc.doc_id
             AND n.path = '/GlossaryTermName/TranslatedName/TermNameString'
            JOIN document d
              ON d.id = n.doc_id
            JOIN query_term gts
              ON d.id = gts.doc_id
             AND gts.path = '/GlossaryTermName/TranslatedName/TranslatedNameStatus'
             AND LEFT(n.node_loc, 4) = LEFT(gts.node_loc, 4)  -- ES only
    left outer join query_term t
              on t.doc_id = n.doc_id
             AND t.path = '/GlossaryTermName/TranslatedName/@NameType'
             AND LEFT(n.node_loc, 4) = LEFT(t.node_loc, 4)  -- ES only
           WHERE gtc.path = '/GlossaryTermName/GlossaryTermConcept/@cdr:ref'
             AND gtc.int_val = ?
             AND d.active_status = 'A'
             AND gts.value in ('Approved', 'Revision pending')
              -- Don't include the glossary term itself in the also-called list
             AND n.value not in (
                 SELECT q.value
                   FROM query_term q
        LEFT OUTER JOIN query_term d
                     ON d.doc_id = q.doc_id
                    AND d.path = '/GlossaryTermName/TranslatedName/@NameType'
                    AND left(d.node_loc, 4) = left(q.node_loc, 4)
                  WHERE q.doc_id = ?
                    AND q.path = '/GlossaryTermName/TranslatedName/TermNameString'
                    AND d.doc_id is null
                    )
             -- Don't include the alternate names unless they are alternates of the term itself
             AND n.value not in (
                 SELECT q.value
                   FROM query_term q
        LEFT OUTER JOIN query_term d
                     ON d.doc_id = q.doc_id
                    AND d.path = '/GlossaryTermName/TranslatedName/@NameType'
                    AND left(d.node_loc, 4) = left(q.node_loc, 4)
                  WHERE q.doc_id != ?
                    AND q.path = '/GlossaryTermName/TranslatedName/TermNameString'
                    AND d.doc_id is NOT null
                    )
           ORDER BY n.value
     </xsl:when>
    </xsl:choose>
   </xsl:variable>

   <!--
   We need two different queries depending on the language attribute

   Since we need two individual queries for EN and ES anyway we
   don't need to use the namePath and statusPath variables
   ================================================================= -->
   <!--
   <xsl:variable                  name = "namePath">
    <xsl:choose>
     <xsl:when                    test = "$language = 'en'">
      <xsl:text>TermName</xsl:text>
     </xsl:when>
     <xsl:when                    test = "$language = 'es'">
      <xsl:text>TranslatedName</xsl:text>
     </xsl:when>
    </xsl:choose>
   </xsl:variable>

   <xsl:variable                  name = "statusPath">
    <xsl:choose>
     <xsl:when                    test = "$language = 'en'">
      <xsl:text>TermNameStatus</xsl:text>
     </xsl:when>
     <xsl:when                    test = "$language = 'es'">
      <xsl:text>TranslatedName/TranslatedNameStatus</xsl:text>
     </xsl:when>
    </xsl:choose>
   </xsl:variable>
   -->



   <xsl:variable                  name = "queryRows"
                                select = "document(cdr:escape-uri(
                                            concat('cdrutil:/sql-query/',
                                                   $sqlGTNQuery,
                                                   '~', $sqlGTCId,
                                                   '~', $gtnNormId,
                                                   '~', $gtnNormId
                                                   )))"/>

   <!--
   Also-called is only added if the SQL query returns with a record
   ================================================================ -->
   <xsl:if                        test = "$queryRows/SqlResult/row">
    <xsl:choose>
     <!--
     A) Only one Also-called exists
     ============================== -->
     <xsl:when                    test = "count($queryRows/SqlResult/row) = 1">
      <xsl:choose>
       <xsl:when                  test = "$language = 'en'">
        <xsl:text> Also called </xsl:text>
       </xsl:when>
       <xsl:when                  test = "$language = 'es'">
        <xsl:text> Tambi&#xE9;n se llama </xsl:text>
       </xsl:when>
      </xsl:choose>
      <xsl:value-of             select = "$queryRows
                                             /SqlResult
                                             /row
                                             /col[@name='value']"/>
      <xsl:text>.</xsl:text>
     </xsl:when>
     <!--
     B) Exactly two Also-calleds exist
     ================================= -->
     <xsl:when                    test = "count($queryRows/SqlResult/row) = 2">
      <xsl:choose>
       <xsl:when                  test = "$language = 'en'">
        <xsl:text> Also called </xsl:text>
       </xsl:when>
       <xsl:when                  test = "$language = 'es'">
        <xsl:text> Tambi&#xE9;n se llama </xsl:text>
       </xsl:when>
      </xsl:choose>
      <xsl:value-of             select = "$queryRows
                                             /SqlResult
                                             /row[@id = 1]
                                             /col[@name='value']"/>
      <xsl:choose>
       <xsl:when                  test = "$language = 'en'">
        <xsl:text> and </xsl:text>
       </xsl:when>
       <xsl:when                  test = "$language = 'es'">
        <xsl:text> y </xsl:text>
       </xsl:when>
      </xsl:choose>
      <xsl:value-of             select = "$queryRows
                                             /SqlResult
                                             /row[@id = 2]
                                             /col[@name='value']"/>
      <xsl:text>.</xsl:text>
     </xsl:when>
     <!--
     C) More than two Also-called exist
     ================================== -->
     <xsl:otherwise>
      <xsl:choose>
       <xsl:when                  test = "$language = 'en'">
        <xsl:text> Also called </xsl:text>
       </xsl:when>
       <xsl:when                  test = "$language = 'es'">
        <xsl:text> Tambi&#xE9;n se llama </xsl:text>
       </xsl:when>
      </xsl:choose>
      <xsl:for-each             select = "$queryRows/SqlResult/row">
       <xsl:value-of            select = "col[@name='value']"/>

       <xsl:choose>
        <xsl:when                 test = "position() = last()">
         <xsl:text>.</xsl:text>
        </xsl:when>
        <!--
        Punctuation is different between English and Spanish
        =================================================== -->
        <xsl:when                  test = "position()+1 = last()">
         <xsl:choose>
          <xsl:when                test = "$language = 'en'">
           <xsl:text>, and </xsl:text>
          </xsl:when>
          <xsl:when                test = "$language = 'es'">
           <xsl:text> y </xsl:text>
          </xsl:when>
         </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
         <xsl:text>, </xsl:text>
        </xsl:otherwise>
       </xsl:choose>

      </xsl:for-each>
     </xsl:otherwise>
    </xsl:choose>
   </xsl:if>
  </xsl:element>
 </xsl:template>


 <!--
 =====================================================================
 Replacing the place holders within the definition text with the
 appropriate text definitions.
 ===================================================================== -->
 <xsl:template                   match = "PlaceHolder"
                                  mode = "copy">
  <xsl:param                      name = "language"
                                select = "'en'"/>
  <xsl:param                      name = "audience"
                                select = "'Patient'"/>

  <xsl:variable                   name = "ph"
                                select = "@name"/>
  <xsl:variable                   name = "termName">
   <xsl:choose>
    <xsl:when                     test = "$language = 'en'">
     <xsl:value-of              select = "//TermName/
                                            TermNameString"/>
    </xsl:when>
    <xsl:when                     test = "$language = 'es'">
     <!--
     There are a few terms for which a Spanish definition exists but not a
     Spanish term name (i.e. windpipe).  For these terms the English term
     will have to be substituted.
     ===================================================================== -->
     <xsl:choose>
      <xsl:when                   test = "//TranslatedName[@language = 'es']">
       <xsl:value-of            select = "//TranslatedName[@language = 'es']/
                                            TermNameString"/>
      </xsl:when>
      <xsl:otherwise>
       <xsl:value-of            select = "//TermName/TermNameString"/>
       <xsl:text> (en ingl&#xE9;s)</xsl:text>
      </xsl:otherwise>
     </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
     <xsl:text>TBD</xsl:text>
    </xsl:otherwise>
   </xsl:choose>
  </xsl:variable>

  <xsl:choose>
   <!--
   A) The canned name TERMNAME has been specified as a place holder
      We replace the term name with the correct term for this language
   ==================================================================== -->
   <xsl:when                      test = "$ph = 'TERMNAME'">
    <xsl:value-of               select = "$termName"/>
   </xsl:when>
   <!--
   B) The canned name CAPPEDTERMNAME has been entered as a place holder
      We replace the term name and capitalize it unless the
      PreservCase attribute of the TermNameString has been specified
   ==================================================================== -->
   <xsl:when                      test = "$ph = 'CAPPEDTERMNAME'">
    <xsl:choose>
     <!-- Preserve the case of the term name -->
     <xsl:when                    test = "//TermName[@language = $language]/
                                             TermNameString/
                                             @PreserveCase = 'Yes'">


      <xsl:value-of             select = "normalize-space($termName)"/>
     </xsl:when>
     <!-- Cap the term name -->
     <xsl:otherwise>
      <xsl:call-template          name = "convertCase">
       <xsl:with-param            name = "convString"
                                select = "substring(
                                           normalize-space($termName), 1, 1)"/>
       <xsl:with-param            name = "convertTo"
                                select = "'proper'"/>
      </xsl:call-template>
      <xsl:value-of             select = "substring(
                                           normalize-space($termName), 2)"/>
     </xsl:otherwise>
    </xsl:choose>
   </xsl:when>
   <!--
   C) Replace the PlaceHolder attribute string with the proper
      ReplacementText element
   ==================================================================== -->
   <xsl:otherwise>
    <!--
    In case the same PlaceHolder string is used in the English as well
    as Spanish section we need to ensure to pick up the right replacement
    text for the correct language.
    ===================================================================== -->
    <xsl:choose>
     <xsl:when                    test = "$language = 'en'">
      <xsl:choose>
       <xsl:when                  test = "/GlossaryTermName
                                           /ReplacementText[@name = $ph]">
        <xsl:value-of           select = "normalize-space(
                                           /GlossaryTermName
                                           /ReplacementText[@name = $ph])"/>
       </xsl:when>
       <xsl:otherwise>
        <xsl:value-of           select = "//GlossaryTermConcept
                                           /TermDefinition[Audience = $audience]
                                           /ReplacementText[@name = $ph]"/>
       </xsl:otherwise>
      </xsl:choose>
     </xsl:when>
     <xsl:when                    test = "$language = 'es'">
      <xsl:choose>
       <xsl:when                  test = "//GlossaryTermConcept
                                           /TranslatedTermDefinition[Audience = $audience]
                                           /ReplacementText[@name = $ph]">
        <xsl:value-of           select = "//GlossaryTermConcept
                                           /TranslatedTermDefinition[Audience = $audience]
                                           /ReplacementText[@name = $ph]"/>

       </xsl:when>
       <xsl:otherwise>
        <xsl:value-of           select = "normalize-space(
                                           /GlossaryTermName
                                           /ReplacementText[@name = $ph])"/>
       </xsl:otherwise>
      </xsl:choose>
     </xsl:when>
    </xsl:choose>
   </xsl:otherwise>
  </xsl:choose>
<!--
      <xsl:value-of             select = "normalize-space(
                                           //TranslatedTermDefinition/
                                             ReplacementText[@name = $ph])"/>
-->
 </xsl:template>


 <!--
 ===================================================================
 Template for extracting SummaryRef Definition
 =================================================================== -->
 <xsl:template                   match = "SummaryRef"
                                  mode = "copy">
  <xsl:variable                   name = "hrefId"
                                select = "@cdr:href"/>
  <xsl:variable                   name = "hrefNormId"
                                select = "number(
                                           substring-before(
                                           concat(
                                           substring-after(@cdr:href, 'CDR'),
                                                               '#'), '#'))"/>
    <!--
    Extracting the content of the SummaryURL attribute to be used for
    populating the url attribute of the SummaryRef element.  This
    information has to be retrieved via a SQL query from the database
    ================================================================= -->
    <xsl:variable                 name = "sqlQuery">
     SELECT path, value
       FROM query_term_pub
      WHERE doc_id = ?
        AND path = '/Summary/SummaryMetaData/SummaryURL/@cdr:xref'
    </xsl:variable>

    <!--
    Note: Don't perform a normalize-space here since it would convert
          the resulting node into a string
    ================================================================== -->
    <xsl:variable                 name = "queryRows"
                                select = "document(cdr:escape-uri(
                                           concat('cdrutil:/sql-query/',
                                                   $sqlQuery,
                                                   '~',
                                                   $hrefNormId)))"/>
    <!--
    Note:  The url created by function getSummaryURL has no trailing
           slash ('/'), specifies the domain as http://cancer.gov and
           is normalized
    ================================================================= -->
    <xsl:variable                 name = "url">
     <xsl:call-template           name = "getSummaryURL">
      <xsl:with-param             name = "url"
                                select = "normalize-space(
                                            $queryRows
                                            /SqlResult
                                            /row

                                            /col[@name='value'])"/>

     </xsl:call-template>
    </xsl:variable>

    <!--
    The SummaryRef url attribute is populated from the xref attribute of
    the SummaryURL element displaying the full path without the domain
    ===================================================================== -->
  <SummaryRef>
   <xsl:attribute                 name = "href">
    <xsl:value-of               select = "$hrefId"/>
   </xsl:attribute>
   <xsl:attribute                 name = "url">
    <xsl:choose>
     <xsl:when                    test = "starts-with($url, 'http')">
      <xsl:value-of             select = "substring-after($url, '.gov')"/>
     </xsl:when>

     <xsl:otherwise>


      <xsl:value-of             select = "$url"/>
     </xsl:otherwise>
    </xsl:choose>
   </xsl:attribute>
   <xsl:apply-templates/>
  </SummaryRef>
 </xsl:template>


 <!--
 ==============================================================
 Template for extracting External Ref Definition
 ============================================================== -->
 <xsl:template                   match = "ExternalRef">
  <ExternalRef>
   <xsl:attribute                 name = "xref">
    <xsl:value-of               select = "@cdr:xref"/>
   </xsl:attribute>
   <xsl:apply-templates/>
  </ExternalRef>
 </xsl:template>
</xsl:transform>
